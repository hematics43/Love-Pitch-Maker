<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Love Pitch Recorder with Graphs</title>
  <style>
    body {
      background: linear-gradient(to bottom right, #ffc6e5, #ffe8f0);
      color: #c92c6d;
      font-family: 'Comic Sans MS', cursive;
      text-align: center;
      padding: 40px;
    }

    h1 {
      font-size: 2.5em;
    }

    #freq {
      font-size: 2em;
      margin: 20px 0;
      font-weight: bold;
      color: #ff2d6f;
    }

    button {
      margin: 10px;
      padding: 10px 20px;
      background: #ff69b4;
      border: none;
      border-radius: 20px;
      color: white;
      font-size: 1.2em;
      cursor: pointer;
      box-shadow: 0 0 10px #ff69b4;
    }

    #saved {
      margin-top: 30px;
    }

    #savedList {
      max-height: 150px;
      overflow-y: auto;
      padding: 10px;
      border: 2px dashed #ff99cc;
      border-radius: 10px;
      background: #fff0f6;
      font-size: 1.1em;
      margin-bottom: 30px;
    }

    canvas {
      border: 2px solid #ff69b4;
      border-radius: 15px;
      background: #fff0f6;
      box-shadow: 0 0 15px #ff8dc7;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>üíï Love Pitch Recorder üíï</h1>
  <p>You're speaking in a frequency of love!</p>
  <div id="freq">Waiting for love...</div>

  <button onclick="savePitch()">üíæ Save Pitch</button>
  <button onclick="saveGraph()">üñºÔ∏è Save Waveform</button>

  <div id="saved">
    <h2>Saved Frequencies üíò</h2>
    <div id="savedList">None yet...</div>
  </div>

  <canvas id="waveformCanvas" width="600" height="150"></canvas>
  <canvas id="spectrumCanvas" width="600" height="150"></canvas>
  <canvas id="pitchGraph" width="600" height="150"></canvas>

  <script>
    let latestFreq = -1;
    const savedFrequencies = [];

    function savePitch() {
      if (latestFreq !== -1) {
        savedFrequencies.push(latestFreq.toFixed(2));
        updateSavedList();
        updatePitchGraph();
      }
    }

    function saveGraph() {
      const canvas = document.getElementById("waveformCanvas");
      const link = document.createElement("a");
      link.download = `love_waveform_${Date.now()}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    }

    function updateSavedList() {
      const listDiv = document.getElementById("savedList");
      if (savedFrequencies.length === 0) {
        listDiv.innerHTML = "None yet...";
        return;
      }
      listDiv.innerHTML = savedFrequencies.map(f => `üíò ${f} Hz`).join("<br>");
    }

    async function startAudio() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(stream);

      // Waveform Analyser
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const waveformData = new Float32Array(analyser.fftSize);
      source.connect(analyser);

      // Spectrum Analyser
      const spectrumAnalyser = audioCtx.createAnalyser();
      spectrumAnalyser.fftSize = 256;
      const spectrumData = new Uint8Array(spectrumAnalyser.frequencyBinCount);
      source.connect(spectrumAnalyser);

      const waveformCanvas = document.getElementById("waveformCanvas");
      const waveformCtx = waveformCanvas.getContext("2d");

      const spectrumCanvas = document.getElementById("spectrumCanvas");
      const spectrumCtx = spectrumCanvas.getContext("2d");

      const pitchCanvas = document.getElementById("pitchGraph");
      const pitchCtx = pitchCanvas.getContext("2d");

      function autoCorrelate(buffer, sampleRate) {
        let SIZE = buffer.length;
        let MAX_SAMPLES = Math.floor(SIZE / 2);
        let bestOffset = -1;
        let bestCorrelation = 0;
        let rms = 0;

        for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) return -1;

        let lastCorrelation = 1;
        for (let offset = 0; offset < MAX_SAMPLES; offset++) {
          let correlation = 0;
          for (let i = 0; i < MAX_SAMPLES; i++) {
            correlation += Math.abs(buffer[i] - buffer[i + offset]);
          }
          correlation = 1 - (correlation / MAX_SAMPLES);
          if (correlation > 0.9 && correlation > lastCorrelation) {
            bestCorrelation = correlation;
            bestOffset = offset;
          }
          lastCorrelation = correlation;
        }

        return bestCorrelation > 0.01 ? sampleRate / bestOffset : -1;
      }

      function drawWaveform() {
        analyser.getFloatTimeDomainData(waveformData);
        waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
        waveformCtx.beginPath();
        waveformCtx.lineWidth = 2;
        waveformCtx.strokeStyle = "#ff2d6f";

        const sliceWidth = waveformCanvas.width / waveformData.length;
        let x = 0;
        for (let i = 0; i < waveformData.length; i++) {
          const v = waveformData[i] * 0.5 + 0.5;
          const y = v * waveformCanvas.height;
          if (i === 0) waveformCtx.moveTo(x, y);
          else waveformCtx.lineTo(x, y);
          x += sliceWidth;
        }
        waveformCtx.stroke();
      }

      function drawSpectrum() {
        spectrumAnalyser.getByteFrequencyData(spectrumData);
        spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

        const barWidth = (spectrumCanvas.width / spectrumData.length) * 1.5;
        let x = 0;

        for (let i = 0; i < spectrumData.length; i++) {
          const barHeight = spectrumData[i];
          spectrumCtx.fillStyle = `hsl(${i * 5}, 100%, 70%)`;
          spectrumCtx.fillRect(x, spectrumCanvas.height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }
      }

      function updatePitchGraph() {
        pitchCtx.clearRect(0, 0, pitchCanvas.width, pitchCanvas.height);
        if (savedFrequencies.length < 2) return;

        pitchCtx.beginPath();
        pitchCtx.strokeStyle = "#c92c6d";
        pitchCtx.lineWidth = 2;

        const step = pitchCanvas.width / (savedFrequencies.length - 1);
        for (let i = 0; i < savedFrequencies.length; i++) {
          const x = i * step;
          const y = pitchCanvas.height - (savedFrequencies[i] / 1000) * pitchCanvas.height;
          if (i === 0) pitchCtx.moveTo(x, y);
          else pitchCtx.lineTo(x, y);
        }
        pitchCtx.stroke();
      }

      function update() {
        analyser.getFloatTimeDomainData(waveformData);
        const freq = autoCorrelate(waveformData, audioCtx.sampleRate);
        latestFreq = freq;
        document.getElementById("freq").textContent =
          freq !== -1 ? `‚ù§Ô∏è ${freq.toFixed(2)} Hz` : "Waiting for love...";

        drawWaveform();
        drawSpectrum();

        requestAnimationFrame(update);
      }

      update();
    }

    startAudio().catch(() => alert("Microphone access denied or not supported."));
  </script>
</body>
</html>
