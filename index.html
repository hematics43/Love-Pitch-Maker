<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Love Pitch Tattoo Wave</title>
  <style>
    body {
      background: linear-gradient(to bottom right, #ffc6e5, #ffe8f0);
      color: #c92c6d;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      text-align: center;
      padding: 40px;
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    #freq {
      font-size: 2em;
      margin-top: 10px;
      color: #ff2d6f;
      font-weight: bold;
    }

    button {
      margin: 10px 5px;
      padding: 10px 20px;
      background: #ff69b4;
      border: none;
      border-radius: 20px;
      color: white;
      font-size: 1.2em;
      cursor: pointer;
      box-shadow: 0 0 10px #ff69b4;
    }

    #saved {
      margin-top: 25px;
    }

    #saved h2 {
      font-size: 1.5em;
    }

    #savedList {
      max-height: 150px;
      overflow-y: auto;
      padding: 10px;
      border: 2px dashed #ff99cc;
      border-radius: 10px;
      background: #fff0f6;
      font-size: 1.1em;
    }

    canvas {
      border: 2px solid #ff69b4;
      border-radius: 15px;
      box-shadow: 0 0 15px #ff8dc7;
      background-color: #fff0f6;
      margin-top: 20px;
    }

    .tattoo-hint {
      margin-top: 10px;
      font-style: italic;
      font-size: 0.9em;
      color: #aa2c5f;
    }
  </style>
</head>
<body>
  <h1>üíï Love Pitch Tattoo Wave üíï</h1>
  <p>Speak your love. Save your sound. Wear your wave. üéôÔ∏èüíò</p>
  <div id="freq">Waiting for love...</div>

  <button onclick="savePitch()">üíæ Save Pitch</button>
  <button onclick="saveGraph()">üñºÔ∏è Save Graph as Image</button>

  <div id="saved">
    <h2>Saved Frequencies üíò</h2>
    <div id="savedList">None yet...</div>
  </div>

  <canvas id="visualizer" width="600" height="150"></canvas>
  <div class="tattoo-hint">üñ§ Save the waveform above as a tattoo design</div>

  <script>
    let latestFreq = -1;
    const savedFrequencies = [];

    function savePitch() {
      if (latestFreq !== -1) {
        savedFrequencies.push(latestFreq.toFixed(2));
        updateSavedList();
      }
    }

    function updateSavedList() {
      const listDiv = document.getElementById("savedList");
      if (savedFrequencies.length === 0) {
        listDiv.innerHTML = "None yet...";
        return;
      }
      listDiv.innerHTML = savedFrequencies
        .map(freq => `üíò ${freq} Hz`)
        .join("<br>");
    }

    function saveGraph() {
      const canvas = document.getElementById("visualizer");
      const link = document.createElement("a");
      link.download = `love_wave_${Date.now()}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    }

    async function startAudio() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaStreamSource(stream);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      const data = new Float32Array(bufferLength);

      source.connect(analyser);

      const canvas = document.getElementById("visualizer");
      const ctx = canvas.getContext("2d");

      function drawWaveform() {
        analyser.getFloatTimeDomainData(data);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = "#000"; // tattoo-friendly black waveform
        ctx.lineWidth = 2;

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const v = data[i] * 0.5 + 0.5;
          const y = v * canvas.height;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
          x += sliceWidth;
        }
        ctx.stroke();
        requestAnimationFrame(drawWaveform);
      }

      function autoCorrelate(buffer, sampleRate) {
        let SIZE = buffer.length;
        let MAX_SAMPLES = Math.floor(SIZE / 2);
        let bestOffset = -1;
        let bestCorrelation = 0;
        let rms = 0;

        for (let i = 0; i < SIZE; i++) {
          const val = buffer[i];
          rms += val * val;
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) return -1;

        let lastCorrelation = 1;
        for (let offset = 0; offset < MAX_SAMPLES; offset++) {
          let correlation = 0;
          for (let i = 0; i < MAX_SAMPLES; i++) {
            correlation += Math.abs((buffer[i]) - (buffer[i + offset]));
          }
          correlation = 1 - (correlation / MAX_SAMPLES);
          if (correlation > 0.9 && correlation > lastCorrelation) {
            bestCorrelation = correlation;
            bestOffset = offset;
          }
          lastCorrelation = correlation;
        }

        if (bestCorrelation > 0.01) {
          return sampleRate / bestOffset;
        }
        return -1;
      }

      function updateFreq() {
        analyser.getFloatTimeDomainData(data);
        const freq = autoCorrelate(data, audioCtx.sampleRate);
        latestFreq = freq;
        document.getElementById("freq").textContent =
          freq !== -1 ? `‚ù§Ô∏è ${freq.toFixed(2)} Hz` : "Waiting for love...";
        requestAnimationFrame(updateFreq);
      }

      drawWaveform();
      updateFreq();
    }

    startAudio().catch(err => {
      alert("Microphone access denied or not supported.");
    });
  </script>
</body>
</html>
